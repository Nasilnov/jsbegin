<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script >
//------------------
// Первое задание
// Я думаю, что можно было бы в игре змейка применить замыкания для определения пользовательских настроек по определенному алгоритму.
// То есть сделать что-то аналогичное конструктору в java или php, что бы пользователь не смог ввести туда левые настройки.
// Например

function gameSetting() {
    const settings = {
        rowsCount: 21,
        colsCount: 21,
        speed: 2,
        winFoodCount: 50,
    };
    return {
        init(rows,cols,) {
            settings.rowsCount = (rows <= 50 && rows >= 10) ? rows : settings.rowsCount;
            settings.colsCount = (cols <= 50 && cols >= 10) ? cols : settings.rowsCount;
        },
        getRows() {
            return settings.rowsCount;
        },
        getCols() {
            return settings.colsCount;
        },
    };
};

const myGameSetting = gameSetting();

myGameSetting.init(25,30);

console.log(myGameSetting.getRows());
console.log(myGameSetting.getCols());
//
//-----------------
// Второе задание
//
    if (!("a" in window)) {
        var a = 1;
    }
    alert(a);

// Здесь будет Undefined. Потому что интерпретптор поднимет переменную a, так как она объявленая через var
// но не присвоит ей значение, так как условие не выполнится.
//-------------------
 var b = function a(x) {
     x && a(--x);
 };
 alert(a);

// Здесь будет -  "a is not defined". Потому что функция объявлена через Expression.
// То есть здесь нужно вызывать функцию по имени переменной которой присвоина ссылка на функцию, то есть alert(b).
//-------------------
 function a(x) {
     return x * 2;
 }
 var a;
 alert(a);

// Здесь выведется тело функции, потому что по сути функция в js это разновидность значения переменной, поэтому интерпретатор
// сначало поднимит переменную a как лексическое выражение функции, потом еще раз попытается поднять переменную а, но не переопределит
// ее, так как при объявлении var не будет присвоено никакого значения, и поэтому в переменной а останется функция.
//-------------------
 function b(x, y, a) {
     arguments[2] = 10;
     alert(a);
 }
 b(1, 2, 3);

// Будет 10, потому, что мы заменяем значение третьего аргумента функции на 10, а третий оргумент и есть "a".
//-------------------
 function a() {
     alert(this);
 }
 a.call(null);

// Здесь будет Window, потому что когда null или Undefined передается в качестве первого аргумента для вызова
// в вызываемую функцию передается глобальный объект в качестве этого значения.
//-------------------





</script>


</body>
</html>